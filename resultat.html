<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Vivario ‚Äî R√©sultat</title>
  <link rel="stylesheet" href="style.css?v=700" />
</head>
<body class="page-result">

  <main class="wrap">
    <header class="top">
      <h1 class="brand">Vivario</h1>
      <p class="muted">Merci. Prends une seconde‚Ä¶</p>
    </header>

    <!-- HERO apaisant -->
    <section class="card hero-card">
      <div class="hero-glow" aria-hidden="true"></div>
      <div class="hero-row">
        <div>
          <h2 class="hero-title">Tu peux souffler.</h2>
          <p class="muted hero-sub">
            Ces textes s‚Äôadaptent √† tes r√©ponses. Rien n‚Äôest envoy√© : tout reste sur ton appareil.
          </p>

          <div class="hero-tools">
            <div class="chips" id="chips"></div>

            <!-- ‚úÖ Switch coach -->
            <label class="coach-switch" title="Change le ton des sc√©narios">
              <input type="checkbox" id="coachToggle">
              <span class="coach-pill">
                <span class="coach-dot" aria-hidden="true"></span>
                Coach doux
              </span>
            </label>
          </div>
        </div>

        <div class="hero-orb" aria-hidden="true"></div>
      </div>

      <div class="actions hero-actions">
        <a class="btn primary" href="respiration.html?v=700">ü´Å Respiration guid√©e</a>
        <a class="btn ghost" href="accueil.html?v=700">‚Ü© Accueil</a>
      </div>
    </section>

    <!-- Message final -->
    <section class="card breathe-card">
      <div class="breathe-orb" aria-hidden="true"></div>
      <div class="breathe-center" aria-hidden="true"></div>

      <h2 style="margin:0;">Ton r√©sultat</h2>
      <p class="muted" id="resultMeta" style="margin-top:6px;"></p>

      <div class="result-block bigtext" id="finalMessage"></div>
    </section>

    <!-- Onglets sc√©narios -->
    <section class="card" id="scenariosCard">
      <div class="tabs" role="tablist" aria-label="Sc√©narios Vivario">
        <button class="tab active" role="tab" aria-selected="true" data-tab="main">Juste pour toi</button>
        <button class="tab" role="tab" aria-selected="false" data-tab="step">Un pas concret</button>
        <button class="tab" role="tab" aria-selected="false" data-tab="calm">Apaisement</button>
        <button class="tab" role="tab" aria-selected="false" data-tab="norm">Normalisation</button>
      </div>

      <div class="tabpanes">
        <div class="pane active" role="tabpanel" id="pane-main"></div>
        <div class="pane" role="tabpanel" id="pane-step"></div>
        <div class="pane" role="tabpanel" id="pane-calm"></div>
        <div class="pane" role="tabpanel" id="pane-norm"></div>
      </div>
    </section>

    <!-- Carte avis -->
    <section class="card feedback-card">
      <h3 style="margin:0 0 6px;">Un avis rapide ?</h3>
      <p class="muted" style="margin:0 0 12px; line-height:1.45;">
        Ton retour m‚Äôaide √† rendre Vivario plus utile.
      </p>
      <div class="actions" style="margin-top:0;">
        <a class="btn primary" href="avis.html?v=700">‚úçÔ∏è Donner un avis</a>
        <a class="btn ghost" href="questionnaire.html?v=700">‚Üª Refaire le questionnaire</a>
      </div>
    </section>
  </main>

  <script src="sound.js?v=700"></script>

  <script>
    const STORAGE_KEY = "vivario_session_v1_1";
    const KEY_COACH = "vivario_coach_soft";
    const SCENARIOS_URL = "./scenarios_v1_1.json";

    function esc(s){
      return String(s ?? "").replace(/[&<>"']/g, c => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[c]));
    }
    function renderParagraphs(text){
      return "<p>" + esc(text).replace(/\n\n/g, "</p><p>") + "</p>";
    }

    function setActiveTab(key){
      document.querySelectorAll(".tab").forEach(btn => {
        const on = btn.dataset.tab === key;
        btn.classList.toggle("active", on);
        btn.setAttribute("aria-selected", on ? "true" : "false");
      });
      document.querySelectorAll(".pane").forEach(p => {
        p.classList.toggle("active", p.id === "pane-" + key);
      });
    }

    function themeLabel(id){
      const map = {
        stable: "Stable",
        neutre: "Neutre",
        flou: "Flou",
        charge: "Fatigue",
        indetermine: "Ind√©termin√©",
        lecture: "Lecture",
        reflechir: "R√©fl√©chir",
        parcourir: "Parcourir",
        faible: "Basse",
        travail: "Travail",
        finances: "Finances",
        couple: "Couple",
        famille: "Famille",
        enfants: "Enfants",
        amis: "Lien social",
        sante: "Sant√©",
        addiction: "Habitude",
        evenement: "√âv√©nement",
        multiple: "Multiple",
        rien_de_precis: "Faire le point",
        preferer_pas: "Discret"
      };
      return map[id] || id;
    }

    function chip(text){
      const span = document.createElement("span");
      span.className = "chip";
      span.textContent = text;
      return span;
    }

    function renderChips(session){
      const el = document.getElementById("chips");
      if (!el) return;
      el.innerHTML = "";

      const p = session.profile || {};
      const focus = Array.isArray(p.focus) ? p.focus : [];
      const tone = p.tone ? `√âtat : ${themeLabel(p.tone)}` : "";
      const energy = p.energie ? `√ânergie : ${themeLabel(p.energie)}` : "";

      if (tone) el.appendChild(chip(tone));
      focus.slice(0, 2).forEach(t => el.appendChild(chip(`Focus : ${themeLabel(t)}`)));
      if (energy) el.appendChild(chip(energy));
    }

    // -------------------------
    // ‚úÖ Mini g√©n√©rateur (TEST7)
    // - r√©g√©n√®re scenarios depuis profile + coach
    // - anti-r√©p√©tition inter-onglets
    // -------------------------
    const bust = (url) => url + (url.includes("?") ? "&" : "?") + "v=" + Date.now();

    function normalizeLine(s){
      return String(s || "")
        .toLowerCase()
        .replace(/\s+/g, " ")
        .replace(/[‚Äô']/g, "'")
        .replace(/[^\p{L}\p{N}\s'!?.,-]/gu, "")
        .trim();
    }
    function sigLoose(s){
      return normalizeLine(s)
        .replace(/\b(tu|toi|ton|ta|tes|aujourd'hui|maintenant|vraiment|un peu|juste|simplement)\b/g, "")
        .replace(/\s+/g, " ")
        .trim();
    }
    function hashString(str){
      let h = 2166136261;
      for (let i=0;i<str.length;i++){
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return (h >>> 0);
    }
    function mulberry32(seed){
      return function(){
        let t = (seed += 0x6D2B79F5);
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    function fillTemplate(str, ctx){
      return String(str || "").replace(/\{(\w+)\}/g, (_, k) => {
        const v = ctx[k];
        if (Array.isArray(v)) return v.join(" ‚Ä¢ ");
        return (v !== undefined && v !== null && String(v).length) ? String(v) : "";
      });
    }

    function asBlocks(arr){
      if (!Array.isArray(arr)) return [];
      return arr.map(x => {
        if (typeof x === "string") return { text: x, weight: 1 };
        if (x && typeof x === "object" && typeof x.text === "string") {
          return {
            text: x.text,
            weight: (typeof x.weight === "number" && x.weight > 0) ? x.weight : 1,
            requires: x.requires || {},
            forbids: x.forbids || {},
            tags: Array.isArray(x.tags) ? x.tags : []
          };
        }
        return null;
      }).filter(Boolean);
    }

    function matchRequires(profile, req){
      if (!req || typeof req !== "object") return true;
      const hasAny = (arr, vals) => vals.some(v => (arr||[]).includes(v));
      const hasAll = (arr, vals) => vals.every(v => (arr||[]).includes(v));

      if (req.coach && req.coach !== profile.coach) return false;
      if (req.tone && req.tone !== profile.tone) return false;
      if (req.root && req.root !== profile.root) return false;
      if (req.energie && req.energie !== profile.energie) return false;
      if (req.sortie && req.sortie !== profile.sortie) return false;

      if (Array.isArray(req.themes_any) && req.themes_any.length){
        if (!hasAny(profile.themes, req.themes_any)) return false;
      }
      if (Array.isArray(req.themes_all) && req.themes_all.length){
        if (!hasAll(profile.themes, req.themes_all)) return false;
      }
      if (Array.isArray(req.besoin_any) && req.besoin_any.length){
        if (!hasAny(profile.besoin, req.besoin_any)) return false;
      }
      if (Array.isArray(req.posture_any) && req.posture_any.length){
        if (!hasAny(profile.posture, req.posture_any)) return false;
      }
      if (Array.isArray(req.vecu_any) && req.vecu_any.length){
        if (!hasAny(profile.vecu, req.vecu_any)) return false;
      }
      if (req.low_energy === true && profile.energie !== "faible") return false;
      if (req.not_low_energy === true && profile.energie === "faible") return false;
      return true;
    }

    function matchForbids(profile, fb){
      if (!fb || typeof fb !== "object") return true;
      const hasAny = (arr, vals) => vals.some(v => (arr||[]).includes(v));

      if (fb.coach && fb.coach === profile.coach) return false;
      if (fb.tone && fb.tone === profile.tone) return false;
      if (fb.root && fb.root === profile.root) return false;
      if (fb.energie && fb.energie === profile.energie) return false;
      if (fb.sortie && fb.sortie === profile.sortie) return false;

      if (Array.isArray(fb.themes_any) && fb.themes_any.length){
        if (hasAny(profile.themes, fb.themes_any)) return false;
      }
      if (Array.isArray(fb.besoin_any) && fb.besoin_any.length){
        if (hasAny(profile.besoin, fb.besoin_any)) return false;
      }
      if (fb.low_energy === true && profile.energie === "faible") return false;
      return true;
    }

    function filterBlocks(profile, blocks){
      return blocks.filter(b => {
        if (!b || !b.text) return false;
        if (!matchRequires(profile, b.requires)) return false;
        if (!matchForbids(profile, b.forbids)) return false;
        return true;
      });
    }

    function weightedPick(rng, blocks){
      if (!blocks.length) return null;
      const total = blocks.reduce((s,b) => s + (b.weight || 1), 0);
      let r = rng() * total;
      for (const b of blocks){
        r -= (b.weight || 1);
        if (r <= 0) return b;
      }
      return blocks[blocks.length - 1];
    }

    function pickManyUniqueWeighted(rng, blocks, n, usedLoose){
      const out = [];
      if (!blocks.length || n <= 0) return out;

      const tries = Math.min(160, blocks.length * 8);
      for (let i=0; i<tries && out.length < n; i++){
        const b = weightedPick(rng, blocks);
        if (!b) continue;
        const loose = sigLoose(b.text);
        if (usedLoose.has(loose)) continue;
        usedLoose.add(loose);
        out.push(b);
      }
      return out;
    }

    function flattenByIds(obj, ids){
      const out = [];
      if (!obj || typeof obj !== "object") return out;
      const list = Array.isArray(ids) ? ids : [];
      list.forEach(id => {
        const pack = obj[id];
        if (Array.isArray(pack)) out.push(...pack);
      });
      return out;
    }

    function labelTheme(id){
      const map = {
        travail: "le travail / la pression",
        finances: "les finances",
        couple: "le couple / la relation",
        famille: "la famille",
        enfants: "les enfants / la parentalit√©",
        amis: "le lien social / l‚Äôisolement",
        sante: "la sant√©",
        addiction: "une habitude difficile",
        evenement: "un √©v√©nement r√©cent",
        multiple: "plusieurs choses en m√™me temps",
        rien_de_precis: "le besoin de faire le point",
        preferer_pas: "quelque chose que tu gardes pour toi"
      };
      return map[id] || id;
    }
    function labelNeed(id){
      const map = {
        mots: "mettre des mots",
        comprendre: "comprendre",
        moins_seul: "te sentir moins seul(e)",
        normaliser: "normaliser",
        recul: "prendre du recul",
        presence: "juste √™tre l√†",
        indetermine: "douceur"
      };
      return map[id] || id;
    }
    function labelTone(id){
      const map = {
        stable: "plut√¥t stable",
        neutre: "dans un entre-deux",
        flou: "dans le flou",
        charge: "charg√©(e)",
        indetermine: "difficile √† nommer"
      };
      return map[id] || id;
    }
    function labelEnergy(id){
      const map = {
        lecture: "lecture tranquille",
        reflechir: "r√©flexion douce",
        parcourir: "parcourir sans effort",
        faible: "√©nergie basse",
        indetermine: "rythme du jour"
      };
      return map[id] || id;
    }

    function buildCtx(profile){
      const theme1 = profile.focus?.[0] ? labelTheme(profile.focus[0]) : "ce que tu traverses";
      const theme2 = profile.focus?.[1] ? labelTheme(profile.focus[1]) : "";
      const need1  = profile.besoin?.[0] ? labelNeed(profile.besoin[0]) : "douceur";
      const need2  = profile.besoin?.[1] ? labelNeed(profile.besoin[1]) : "";
      const tone   = labelTone(profile.tone);
      const energy = labelEnergy(profile.energie);
      const themes = (profile.themes || []).map(labelTheme);
      const needs  = (profile.besoin || []).map(labelNeed);
      return { tone, energy, theme1, theme2, need1, need2, themes, needs };
    }

    function buildVariantText(SCEN, profile, variantKey, usedLooseGlobal){
      const meta = SCEN.meta || {};
      const vMeta = (meta.variants && meta.variants[variantKey]) ? meta.variants[variantKey] : {};
      const min = vMeta.min_sentences ?? meta.min_sentences ?? 7;
      const max = vMeta.max_sentences ?? meta.max_sentences ?? 10;

      const seedBase = hashString(JSON.stringify(profile));
      const seed = hashString(`${seedBase}:${variantKey}:${profile.root}:${profile.tone}:${profile.energie}:${profile.sortie}:${profile.coach}`);
      const rng = mulberry32(seed);

      const roots = SCEN.roots || {};
      const modules = SCEN.modules || {};

      const ctx = buildCtx(profile);
      const usedLoose = usedLooseGlobal;

      const B = (arr) => filterBlocks(profile, asBlocks(arr));
      const rootPack = roots[profile.root] || roots.clarification || {};
      const openings = modules.openings || {};
      const toneOpen = openings[profile.tone] || openings.indetermine || [];
      const bridges = modules.bridges || [];
      const closings = modules.closings || [];
      const normalisation = modules.normalisation || [];

      const themePackAll = flattenByIds(modules.themes || {}, profile.themes || []);
      const vecuPackAll = flattenByIds(modules.vecu || {}, profile.vecu || []);
      const posturePackAll = flattenByIds(modules.posture || {}, profile.posture || []);
      const needPackAll = flattenByIds(modules.needs || {}, profile.besoin || []);
      const energyPack = (modules.energy && modules.energy[profile.energie]) ? modules.energy[profile.energie] : [];

      const variantPacks = (modules.variants && modules.variants[variantKey]) ? modules.variants[variantKey] : [];
      const variantClosings = (modules.variant_closings && modules.variant_closings[variantKey]) ? modules.variant_closings[variantKey] : [];

      const blocks = [];
      blocks.push(...pickManyUniqueWeighted(rng, B(rootPack.intro || []), 1, usedLoose));
      blocks.push(...pickManyUniqueWeighted(rng, B(toneOpen), 1, usedLoose));

      if (variantKey === "main" || variantKey === "calm") {
        blocks.push(...pickManyUniqueWeighted(rng, B(bridges), 1, usedLoose));
      }

      const focusIds = Array.isArray(profile.focus) ? profile.focus : [];
      const focusLines = flattenByIds(modules.themes || {}, focusIds);

      blocks.push(...pickManyUniqueWeighted(rng, B(focusLines.length ? focusLines : themePackAll), 1, usedLoose));

      if (variantKey === "norm") blocks.push(...pickManyUniqueWeighted(rng, B(normalisation), 1, usedLoose));

      blocks.push(...pickManyUniqueWeighted(rng, B(needPackAll), 1, usedLoose));
      blocks.push(...pickManyUniqueWeighted(rng, B(variantPacks), (profile.energie === "faible") ? 1 : 2, usedLoose));
      blocks.push(...pickManyUniqueWeighted(rng, B(energyPack), 1, usedLoose));
      blocks.push(...pickManyUniqueWeighted(rng, B(variantClosings), 1, usedLoose));
      blocks.push(...pickManyUniqueWeighted(rng, B(closings), 1, usedLoose));

      let lines = blocks.map(b => fillTemplate(b.text, ctx).trim()).filter(Boolean);

      // trim
      if (lines.length > max) lines = lines.slice(0, max);
      while (lines.length < min && closings.length) {
        const extra = weightedPick(rng, B(closings));
        if (extra?.text) lines.push(fillTemplate(extra.text, ctx));
        if (lines.length >= min) break;
      }

      // dedupe simple final
      const out = [];
      const seen = new Set();
      for (const l of lines){
        const s = sigLoose(l);
        if (!s) continue;
        if (seen.has(s)) continue;
        seen.add(s);
        out.push(l);
      }

      return out.join("\n\n");
    }

    async function regenScenarios(session, coachSoft){
      const draft = session?.draft;
      const profile0 = draft?.profile || session?.profile;
      if (!profile0) return null;

      const profile = { ...profile0, coach: coachSoft ? "soft" : "neutral" };

      const res = await fetch(bust(SCENARIOS_URL), { cache: "no-store" });
      if (!res.ok) throw new Error("scenarios_v1_1.json introuvable");
      const SCEN = await res.json();

      const roots = SCEN.roots || {};
      const rootTitle = roots?.[profile.root]?.title || "Juste pour toi";

      const usedLooseGlobal = new Set(); // ‚úÖ anti-r√©p√©tition inter-onglets

      const main = buildVariantText(SCEN, profile, "main", usedLooseGlobal);
      const step = buildVariantText(SCEN, profile, "step", usedLooseGlobal);
      const calm = buildVariantText(SCEN, profile, "calm", usedLooseGlobal);
      const norm = buildVariantText(SCEN, profile, "norm", usedLooseGlobal);

      const scenarios = [
        { key:"main", title: rootTitle, text: main },
        { key:"step", title: "Un pas concret", text: step },
        { key:"calm", title: "Apaisement", text: calm },
        { key:"norm", title: "Normalisation", text: norm }
      ];

      // met √† jour session
      session.profile = { ...(session.profile||{}), coach: profile.coach };
      session.scenarios = scenarios;
      session.draft = session.draft || {};
      session.draft.coach = profile.coach;
      session.draft.profile = profile;
      session.draft.scenarios = scenarios;

      localStorage.setItem(STORAGE_KEY, JSON.stringify(session));
      return session;
    }

    function fillPanesFromSession(session){
      const scenarios = Array.isArray(session.scenarios) ? session.scenarios : [];
      const map = {};
      scenarios.forEach(s => { if (s && s.key) map[s.key] = s; });

      function fillPane(key, fallbackTitle){
        const pane = document.getElementById("pane-" + key);
        const s = map[key];
        if (!pane) return;

        const title = esc(s?.title || fallbackTitle);
        const text = s?.text ? renderParagraphs(s.text) : "<p class='muted'>Indisponible.</p>";

        pane.innerHTML = `
          <h3 style="margin:0 0 10px;">${title}</h3>
          <div class="scenario-text">${text}</div>
        `;
      }

      fillPane("main", "Juste pour toi");
      fillPane("step", "Un pas concret");
      fillPane("calm", "Apaisement");
      fillPane("norm", "Normalisation");

      const mainTitle = map.main?.title;
      if (mainTitle) {
        const btnMain = document.querySelector('.tab[data-tab="main"]');
        if (btnMain) btnMain.textContent = mainTitle;
      }
    }

    function render() {
      const raw = localStorage.getItem(STORAGE_KEY);

      const finalEl = document.getElementById("finalMessage");
      const metaEl = document.getElementById("resultMeta");

      if (!raw) {
        finalEl.textContent = "Session introuvable. Reviens au questionnaire.";
        metaEl.textContent = "";
        return;
      }

      const session = JSON.parse(raw);

      metaEl.textContent =
        `Version ${session.version} ‚Ä¢ ${new Date(session.createdAt).toLocaleString("fr-FR")}`;

      renderChips(session);
      finalEl.innerHTML = renderParagraphs(session.finalMessage);

      fillPanesFromSession(session);

      // init toggle coach
      const coachToggle = document.getElementById("coachToggle");
      if (coachToggle) {
        coachToggle.checked = (localStorage.getItem(KEY_COACH) === "1");
        coachToggle.addEventListener("change", async () => {
          localStorage.setItem(KEY_COACH, coachToggle.checked ? "1" : "0");

          coachToggle.disabled = true;
          coachToggle.parentElement?.classList.add("loading");

          try{
            const freshRaw = localStorage.getItem(STORAGE_KEY);
            const sess = freshRaw ? JSON.parse(freshRaw) : session;
            const updated = await regenScenarios(sess, coachToggle.checked);
            if (updated) {
              renderChips(updated);
              fillPanesFromSession(updated);
            }
          }catch(e){
            // silencieux
          }finally{
            coachToggle.disabled = false;
            coachToggle.parentElement?.classList.remove("loading");
          }
        });
      }
    }

    document.addEventListener("DOMContentLoaded", () => {
      render();
      document.querySelectorAll(".tab").forEach(btn => {
        btn.addEventListener("click", () => setActiveTab(btn.dataset.tab));
      });
      setActiveTab("main");
    });
  </script>
</body>
</html>